package com.ca.mas.core.util;

import android.content.Context;
import android.content.pm.PackageManager;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;


/**
 * This class is used to execute methods who will provide information
 * about the state of the device related to the Root utility. It's not 100%
 * accurated but it's similiar to what Google Wallet does.
 *
 * -- Methods to test:
 * - Executing 'SU'
 * - Executing 'WICH SU'
 * - Check Root Apps packages installed
 * - Check dangerous App packages installed
 * - Test Key detection
 *
 */
public class RootUtil {

    private static final String TAG = "RootUtil";

    private static final String[] pathsThatShouldNotBeWrtiable = {
            "/system",
            "/system/bin",
            "/system/sbin",
            "/system/xbin",
            "/vendor/bin",
            "/sbin",
            "/etc",
    };

    private static final String[] knownRootAppsPackages = {
            "com.noshufou.android.su",
            "com.noshufou.android.su.elite",
            "eu.chainfire.supersu",
            "com.koushikdutta.superuser",
            "com.thirdparty.superuser",
            "com.yellowes.su",
            "com.topjohnwu.magisk"
    };

    private static final String[] knownDangerousAppsPackages = {
            "com.koushikdutta.rommanager",
            "com.koushikdutta.rommanager.license",
            "com.dimonvideo.luckypatcher",
            "com.chelpus.lackypatch",
            "com.ramdroid.appquarantine",
            "com.ramdroid.appquarantinepro",
            "com.android.vending.billing.InAppBillingService.COIN",
            "com.chelpus.luckypatcher"
    };

    private static final String[] knownRootCloakingPackages = {
            "com.devadvance.rootcloak",
            "com.devadvance.rootcloakplus",
            "de.robv.android.xposed.installer",
            "com.saurik.substrate",
            "com.zachspong.temprootremovejb",
            "com.amphoras.hidemyroot",
            "com.amphoras.hidemyrootadfree",
            "com.formyhm.hiderootPremium",
            "com.formyhm.hideroot"
    };

    /**
     * Checking for SU, this attempts a 'which su'
     * @return true if su found
     */
    public boolean checkSuExists() {
        return executeCommand(new String[] { "su", "-C" });
    }

    /**
     * A variation on the checking for SU, this attempts a 'which su'
     * @return true if su found
     */
    public boolean checkWichSuExists() {

        return executeCommand(new String[] { "which", "su" });
    }

    /**
     * Execute command like in a linux environment
     * @return true if su found
     */
    private boolean executeCommand(String[] commands) {
        if (commands == null) return false;

        Process process = null;
        try {
            process = Runtime.getRuntime().exec(commands);
            BufferedReader in = new BufferedReader(new InputStreamReader(process.getInputStream()));
            return in.readLine() != null;
        } catch (Throwable t) {
            return false;
        } finally {
            if (process != null) process.destroy();
        }
    }

    /**
     * This method checks if any of these paths pathsThatShouldNotBeWrtiable are writable.
     * @return true if one of the dir is writable
     */
    public boolean pathSystemsPermissions(){
        boolean result = false;

        for (String name : pathsThatShouldNotBeWrtiable) {
            File f = new File(name);
            if(f.canWrite()) {
                result = true;
            }
        }

        return result;
    }

    /**
     * This method checks any known Dangerous app package is installed
     * @return true if one of the packages is installed
     */
    public boolean isKnownDangerousAppsPackagesInstalled(Context context) {
        return isAnyPackageFromListInstalled(context, knownDangerousAppsPackages);
    }

    /**
     * This method checks any known Root app package is installed
     * @return true if one of the packages is installed
     */
    public boolean isKnownRootAppsPackagesInstalled(Context context) {
        return isAnyPackageFromListInstalled(context, knownDangerousAppsPackages);
    }

    /**
     * Release-Keys and Test-Keys has to do with how the kernel is signed when it is compiled.
     * Test-Keys means it was signed with a custom key generated by a third-party developer.
     * @return true if signed with Test-keys
     */
    public boolean detectTestKeys() {
        String buildTags = android.os.Build.TAGS;

        return buildTags != null && buildTags.contains("test-keys");
    }

    /**
     * Check if any package in the list is installed
     * @param packages - list of packages to search for
     * @param context - list of packages to search for
     * @return true if any of the packages are installed
     */
    private boolean isAnyPackageFromListInstalled(Context context, String[] packages){
        boolean result = false;

        PackageManager pm = context.getPackageManager();

        for (String packageName : packages) {
            try {
                pm.getPackageInfo(packageName, 0);
                result = true;
            } catch (PackageManager.NameNotFoundException e) {
            }
        }

        return result;
    }
}
